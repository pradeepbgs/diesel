var K=Object.create;var{getPrototypeOf:L,defineProperty:B,getOwnPropertyNames:I,getOwnPropertyDescriptor:M}=Object,J=Object.prototype.hasOwnProperty;var Q=(j,q,b)=>{b=j!=null?K(L(j)):{};let z=q||!j||!j.__esModule?B(b,"default",{value:j,enumerable:!0}):b;for(let v of I(j))if(!J.call(z,v))B(z,v,{get:()=>j[v],enumerable:!0});return z},H=new WeakMap,R=(j)=>{var q=H.get(j),b;if(q)return q;if(q=B({},"__esModule",{value:!0}),j&&typeof j==="object"||typeof j==="function")I(j).map((z)=>!J.call(q,z)&&B(q,z,{get:()=>j[z],enumerable:!(b=M(j,z))||b.enumerable}));return H.set(j,q),q},U=(j,q)=>()=>(q||j((q={exports:{}}).exports,q),q.exports);var V=(j,q)=>{for(var b in q)B(j,b,{get:q[b],enumerable:!0,configurable:!0,set:(z)=>q[b]=()=>z})};var W=(j,q)=>()=>(j&&(q=j(j=0)),q);var X=((j)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(j,{get:(q,b)=>(typeof require!=="undefined"?require:q)[b]}):j)(function(j){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+j+'" is not supported')});class E{children;isEndOfWord;handler;isDynamic;pattern;path;methodMap;segmentCount;params;middlewares;constructor(){this.children={},this.isEndOfWord=!1,this.handler=null,this.isDynamic=!1,this.pattern="",this.path="",this.methodMap=new Map,this.segmentCount=0,this.params=[],this.middlewares=[]}}class F{root;cachedSegments;globalMiddlewares;constructor(){this.root=new E,this.cachedSegments=new Map,this.globalMiddlewares=[]}pushMidl(j,...q){let b=this.root,z=j.split("/").filter(Boolean);if(j==="/"){b.handler=q[0],this.globalMiddlewares.push(...q);return}for(let v of z){let A=v;if(v.startsWith(":"))A=":";else if(v.startsWith("*"))b.middlewares.push(...q);if(!b.children[A])b.children[A]=new E;b=b.children[A]}b.middlewares.push(...q),b.handler=q[0]}insert(j,q){let b=this.root,z=j.split("/").filter(Boolean);if(this.cachedSegments.set(j,z),j==="/"){b.isEndOfWord=!0,b.handler=q.handler,b.path=j,b.methodMap.set(q.method,q.handler),b.segmentCount=0,b.params=[];return}for(let v of z){let A=v,C=!1;if(v.startsWith(":"))C=!0,A=":";if(v==="*")A="*";if(!b.children[A])b.children[A]=new E;b=b.children[A],b.isDynamic=C,b.pattern=v}b.params=z.filter((v)=>v.startsWith(":")).map((v)=>v.slice(1)),b.isEndOfWord=!0,b.path=j,b.segmentCount=z.length,b.methodMap.set(q.method,q.handler),b.handler=q.handler}search(j,q){let b=this.root,z=this.cachedSegments.get(j)||j.split("/").filter(Boolean),v=[...this.globalMiddlewares];for(let C of z){let G=C;if(b.children[G])b=b.children[G];else if(b.children[":"])b=b.children[":"];else if(b.children["*"]){b=b.children["*"];break}else return{handler:v};if(b.middlewares.length>0)v.push(...b.middlewares)}if(!b.isEndOfWord||b.segmentCount!==z.length)return{handler:v};let A=b.methodMap.get(q);if(A)v.push(A);return{params:b.params,handler:v}}}class O{trie=new F;cache=new Map;add(j,q,b){this.trie.insert(q,{method:j,handler:b})}addMiddleware(j,...q){this.trie.pushMidl(j,...q)}find(j,q){return this.trie.search(q,j)}}export{F as default,O as TrieRouter};
