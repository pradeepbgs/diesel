var J=Object.create;var{getPrototypeOf:K,defineProperty:C,getOwnPropertyNames:H,getOwnPropertyDescriptor:L}=Object,I=Object.prototype.hasOwnProperty;var O=(j,q,b)=>{b=j!=null?J(K(j)):{};let v=q||!j||!j.__esModule?C(b,"default",{value:j,enumerable:!0}):b;for(let z of H(j))if(!I.call(v,z))C(v,z,{get:()=>j[z],enumerable:!0});return v},G=new WeakMap,Q=(j)=>{var q=G.get(j),b;if(q)return q;if(q=C({},"__esModule",{value:!0}),j&&typeof j==="object"||typeof j==="function")H(j).map((v)=>!I.call(q,v)&&C(q,v,{get:()=>j[v],enumerable:!(b=L(j,v))||b.enumerable}));return G.set(j,q),q},R=(j,q)=>()=>(q||j((q={exports:{}}).exports,q),q.exports);var U=(j,q)=>{for(var b in q)C(j,b,{get:q[b],enumerable:!0,configurable:!0,set:(v)=>q[b]=()=>v})};var V=(j,q)=>()=>(j&&(q=j(j=0)),q);var W=((j)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(j,{get:(q,b)=>(typeof require!=="undefined"?require:q)[b]}):j)(function(j){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+j+'" is not supported')});class E{children;isEndOfWord;handler;isDynamic;pattern;path;methodMap;segmentCount;params;constructor(){this.children={},this.isEndOfWord=!1,this.handler=null,this.isDynamic=!1,this.pattern="",this.path="",this.methodMap=new Map,this.segmentCount=0,this.params=[]}}class F{root;cachedSegments;constructor(){this.root=new E,this.cachedSegments=new Map}pushMidl(j,...q){let b=this.root,v=j.split("/").filter(Boolean);if(j==="/"){b.handler=q[0];return}for(let z of v){let A=z;if(z.startsWith(":"))A=":";if(!b.children[A])b.children[A]=new E;b=b.children[A]}b.handler=q[0]}insert(j,q){let b=this.root,v=j.split("/").filter(Boolean);if(this.cachedSegments.set(j,v),j==="/"){b.isEndOfWord=!0,b.handler=q.handler,b.path=j,b.methodMap.set(q.method,q.handler),b.segmentCount=0,b.params=[];return}for(let z of v){let A=z,B=!1;if(z.startsWith(":"))B=!0,A=":";if(z==="*")A="*";if(!b.children[A])b.children[A]=new E;b=b.children[A],b.isDynamic=B,b.pattern=z}b.params=v.filter((z)=>z.startsWith(":")).map((z)=>z.slice(1)),b.isEndOfWord=!0,b.path=j,b.segmentCount=v.length,b.methodMap.set(q.method,q.handler),b.handler=q.handler}search(j,q){let b=this.root,v=this.cachedSegments.get(j)||j.split("/").filter(Boolean);for(let A of v){let B=A;if(b.children[B])b=b.children[B];else if(b.children[":"])b=b.children[":"];else if(b.children["*"]){b=b.children["*"];break}else return null}if(!b.isEndOfWord||b.segmentCount!==v.length)return null;let z=b.methodMap.get(q);if(!z)return null;return{handler:z,params:b.params}}}class M{trie=new F;cache=new Map;add(j,q,b){this.trie.insert(q,{method:j,handler:b})}addMiddleware(j,...q){}find(j,q){return this.trie.search(q,j)}}export{F as default,M as TrieRouter};
